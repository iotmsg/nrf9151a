<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Controlador nRF9151</title>
  <!-- Pinar versión mqtt.js -->
  <script src="https://unpkg.com/mqtt@4.3.7/dist/mqtt.min.js"></script>
  <style>
    canvas { border-radius: 50%; cursor: crosshair; }
    #colorPreview {
      display: inline-block;
      width: 40px;
      height: 40px;
      border: 1px solid black;
      margin-left: 10px;
      vertical-align: middle;
    }
  </style>
</head>
<body>
  <h2>Estado MQTT: <span id="status">Conectando...</span></h2>

  <button id="btnRojo">Rojo</button>
  <button id="btnVerde">Verde</button>
  <button id="btnAzul">Azul</button>

  <h3>Selecciona color</h3>
  <canvas id="colorCanvas" width="300" height="300"></canvas><br>

  <label for="brightness">Brillo:</label>
  <input type="range" id="brightness" min="0" max="100" value="100" />
  <span id="brightnessVal">100%</span>

  <div>
    <span id="colorValue">---</span>
    <span id="colorPreview"></span>
  </div>

  <pre id="output"></pre>

  <h3>Datos recibidos:</h3>
  <table id="dataTable" border="1" cellpadding="4">
    <thead>
      <tr>
        <th>Nombre</th>
        <th>Valor</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

<script>
  const subscribeTopic = "topicpub";
  const publishTopic = "topicsub";

  const client = mqtt.connect("wss://a35113782c9343f995cf89ab41c31da6.s1.eu.hivemq.cloud:8884/mqtt", {
    protocolVersion: 5,
    clean: true,
    username: "webaccess1",
    password: "L54Bk3278",
    reconnectPeriod: 2000,
    connectTimeout: 30000,
    clientId: "web_" + Math.random().toString(16).slice(2,10)
  });

  const statusEl = document.getElementById("status");
  const outputEl = document.getElementById("output");
  const colorValue = document.getElementById("colorValue");
  const colorPreview = document.getElementById("colorPreview");
  const brightnessSlider = document.getElementById("brightness");
  const brightnessVal = document.getElementById("brightnessVal");

  let lastR = null, lastG = null, lastB = null;
  let brightnessFactor = brightnessSlider.value / 100;

  // Interpreta "yy/mm/dd,HH:MM:SS+TZ" IGNORANDO el +TZ y asumiendo que HH:MM:SS es UTC real.
  function parseModemTimeIgnoringOffset(str) {
    const m = str.match(/^(\d{2})\/(\d{2})\/(\d{2}),(\d{2}):(\d{2}):(\d{2})([+-])(\d{2})$/);
    if (!m) return null;
    const [, yy, mm, dd, HH, MM, SS] = m;
    const year = 2000 + parseInt(yy, 10);
    // Construimos un Date a partir de UTC puro (ignora offset del string)
    const utcMs = Date.UTC(year, parseInt(mm,10)-1, parseInt(dd,10),
                           parseInt(HH,10), parseInt(MM,10), parseInt(SS,10));
    return new Date(utcMs);
  }

  // Evento del slider de brillo
  brightnessSlider.addEventListener("input", () => {
    brightnessVal.textContent = brightnessSlider.value + "%";
    brightnessFactor = brightnessSlider.value / 100;

    let r, g, b;

    if (lastR !== null && lastG !== null && lastB !== null) {
      r = Math.min(255, Math.round(lastR * brightnessFactor));
      g = Math.min(255, Math.round(lastG * brightnessFactor));
      b = Math.min(255, Math.round(lastB * brightnessFactor));
    } else {
      r = g = b = Math.min(255, Math.round(255 * brightnessFactor));
      lastR = lastG = lastB = 255;
    }

    const hex = rgbToHex(r, g, b);
    colorValue.textContent = `${hex} (R:${r}, G:${g}, B:${b})`;
    colorPreview.style.backgroundColor = hex;
    publishColor(r, g, b);
  });

  client.on("connect", () => {
    statusEl.textContent = "Conectado";
    client.subscribe(subscribeTopic);
  });

  client.on("message", (topic, message) => {
    const timestamp = new Date().toLocaleTimeString();
    const msgStr = message.toString();
    outputEl.textContent = `[${timestamp}] Tópico: ${topic}\n${msgStr}`;

    const tableBody = document.querySelector("#dataTable tbody");
    tableBody.innerHTML = "";

    try {
      const data = JSON.parse(msgStr);
      if (data.time) {
        const d = parseModemTimeIgnoringOffset(data.time); // trata HH:MM:SS como UTC
        if (d) {
          // Usar la zona horaria del SISTEMA del navegador (aplica DST automáticamente)
          const fmtDate = new Intl.DateTimeFormat(undefined, {
            dateStyle: 'short',
            // timeZone: undefined -> usa la del sistema
          }).format(d);
          const fmtTime = new Intl.DateTimeFormat(undefined, {
            timeStyle: 'medium',
            hourCycle: 'h23',   // Fuerza formato 24h
            hour12: false       // Alternativa: asegura que no use AM/PM
          }).format(d);
          data["fecha_local"] = fmtDate;
          data["hora_local"]  = fmtTime;
        } else {
          data["fecha_local"] = "-";
          data["hora_local"]  = "-";
        }
        delete data.time;
      }

      Object.entries(data).forEach(([key, value]) => {
        const row = document.createElement("tr");
        const cellKey = document.createElement("td");
        const cellVal = document.createElement("td");
        cellKey.textContent = key;
        cellVal.textContent = value;
        row.appendChild(cellKey);
        row.appendChild(cellVal);
        tableBody.appendChild(row);
      });
    } catch (e) {
      const row = document.createElement("tr");
      const cell = document.createElement("td");
      cell.colSpan = 2;
      cell.textContent = "Mensaje no válido: " + msgStr;
      row.appendChild(cell);
      tableBody.appendChild(row);
    }
  });

  client.on("error", (err) => {
    statusEl.textContent = "Error de conexión";
    console.error("MQTT Error:", err);
  });

  const publishFixedColor = (color) => {
    const map = {
      "rojo": { ledr: 255, ledg: 0, ledb: 0 },
      "verde": { ledr: 0, ledg: 255, ledb: 0 },
      "azul": { ledr: 0, ledg: 0, ledb: 255 }
    };
    const payload = {
      ...map[color],
      level: parseInt(brightnessSlider.value, 10)
    };
    lastR = map[color].ledr;
    lastG = map[color].ledg;
    lastB = map[color].ledb;
    console.log("Enviando MQTT (fijo):", JSON.stringify(payload));
    client.publish(publishTopic, JSON.stringify(payload));
  };

  const publishColor = (r, g, b) => {
    const payload = {
      ledr: r,
      ledg: g,
      ledb: b,
      level: parseInt(brightnessSlider.value, 10)
    };
    console.log("Enviando MQTT:", JSON.stringify(payload));
    client.publish(publishTopic, JSON.stringify(payload));
  };

  document.getElementById("btnRojo").addEventListener("click", () => publishFixedColor("rojo"));
  document.getElementById("btnVerde").addEventListener("click", () => publishFixedColor("verde"));
  document.getElementById("btnAzul").addEventListener("click", () => publishFixedColor("azul"));

  const canvas = document.getElementById("colorCanvas");
  const ctx = canvas.getContext("2d");
  const image = new Image();
  image.src = "colorwheel-rgb.jpg";

  image.onload = () => {
    ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
  };

  canvas.addEventListener("click", (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor(e.clientX - rect.left);
    const y = Math.floor(e.clientY - rect.top);
    const pixel = ctx.getImageData(x, y, 1, 1).data;

    lastR = pixel[0];
    lastG = pixel[1];
    lastB = pixel[2];

    const r = Math.min(255, Math.round(lastR * brightnessFactor));
    const g = Math.min(255, Math.round(lastG * brightnessFactor));
    const b = Math.min(255, Math.round(lastB * brightnessFactor));

    const hex = rgbToHex(r, g, b);
    colorValue.textContent = `${hex} (R:${r}, G:${g}, B:${b})`;
    colorPreview.style.backgroundColor = hex;

    publishColor(r, g, b);
  });

  function rgbToHex(r, g, b) {
    return "#" + [r, g, b].map(x => x.toString(16).padStart(2, "0")).join("");
  }
</script>
</body>
</html>


